<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ultimate Snake Game</title>
    <style>
        :root {
            --primary: #4ecca3;
            --dark: #1a1a2e;
            --light: #b8c2cc;
        }
        
        body {
            margin: 0;
            background: linear-gradient(135deg, #1a1a2e, #16213e);
            color: white;
            font-family: Arial, sans-serif;
            min-height: 100vh;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .game-wrapper {
            display: flex;
            gap: 20px;
            max-width: 1400px;
            margin: 0 auto;
        }

        .game-area {
            flex: 1;
        }

        canvas {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.3);
        }

        .controls {
            width: 300px;
            background: rgba(255, 255, 255, 0.1);
            padding: 20px;
            border-radius: 8px;
        }

        .score {
            font-size: 24px;
            text-align: center;
            color: var(--primary);
            margin-bottom: 20px;
        }

        .mode-selector, .modifier-selector {
            margin-bottom: 20px;
            background: rgba(0, 0, 0, 0.2);
            padding: 15px;
            border-radius: 8px;
        }

        .mode-title {
            color: var(--primary);
            margin-bottom: 10px;
            font-weight: bold;
        }

        .mode-list, .modifier-list {
            max-height: 200px;
            overflow-y: auto;
        }

        .mode-item, .modifier-item {
            padding: 8px;
            margin: 4px 0;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .mode-item:hover, .modifier-item:hover {
            background: rgba(78, 204, 163, 0.2);
        }

        .selected {
            background: rgba(78, 204, 163, 0.3) !important;
            border: 1px solid var(--primary);
        }

        .active-modifiers {
            margin-bottom: 15px;
            padding: 10px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 4px;
        }

        .modifier-tag {
            display: inline-block;
            padding: 4px 8px;
            margin: 2px;
            background: var(--primary);
            border-radius: 12px;
            font-size: 12px;
        }

        button {
            width: 100%;
            padding: 12px;
            background: var(--primary);
            border: none;
            border-radius: 4px;
            color: white;
            font-size: 16px;
            cursor: pointer;
            margin-bottom: 10px;
            transition: all 0.2s;
        }

        button:hover {
            background: #3db892;
            transform: translateY(-2px);
        }

        .status {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 48px;
            color: var(--primary);
            text-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
            display: none;
            text-align: center;
            z-index: 100;
        }

        .info-panel {
            margin-top: 15px;
            padding: 10px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 4px;
        }

        /* Scrollbar styling */
        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.2);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb {
            background: var(--primary);
            border-radius: 4px;
        }
    </style>
</head>
<body>
    <div class="game-wrapper">
        <div class="game-area">
            <canvas id="gameCanvas" width="800" height="800"></canvas>
            <div id="status" class="status"></div>
        </div>
        
        <div class="controls">
            <div class="score">Score: <span id="scoreValue">0</span></div>
            
            <div class="mode-selector">
                <div class="mode-title">Game Modes</div>
                <div class="mode-list">
                    <div class="mode-item selected" data-mode="classic">Classic</div>
                    <div class="mode-item" data-mode="timeAttack">Time Attack</div>
                    <div class="mode-item" data-mode="maze">Maze Runner</div>
                    <div class="mode-item" data-mode="portal">Portal</div>
                    <div class="mode-item" data-mode="infinity">Infinity</div>
                    <div class="mode-item" data-mode="zigzag">Zigzag</div>
                    <div class="mode-item" data-mode="reverse">Reverse</div>
                    <div class="mode-item" data-mode="ghost">Ghost</div>
                    <div class="mode-item" data-mode="chaos">Chaos</div>
                    <div class="mode-item" data-mode="growing">Growing Walls</div>
                    <div class="mode-item" data-mode="shrinking">Shrinking Field</div>
                    <div class="mode-item" data-mode="wind">Wind</div>
                    <div class="mode-item" data-mode="dark">Dark Mode</div>
                    <div class="mode-item" data-mode="gold">Gold Rush</div>
                    <div class="mode-item" data-mode="survival">Survival</div>
                </div>
            </div>

            <div class="modifier-selector">
                <div class="mode-title">Modifiers (Max 3)</div>
                <div class="modifier-list">
                    <div class="modifier-item" data-modifier="speed">Speed Up</div>
                    <div class="modifier-item" data-modifier="rainbow">Rainbow Snake</div>
                    <div class="modifier-item" data-modifier="ghost">Ghost Mode</div>
                    <div class="modifier-item" data-modifier="tiny">Tiny Snake</div>
                    <div class="modifier-item" data-modifier="giant">Giant Snake</div>
                    <div class="modifier-item" data-modifier="reverse">Reverse Controls</div>
                    <div class="modifier-item" data-modifier="multiplier">Score Multiplier</div>
                    <div class="modifier-item" data-modifier="portal">Random Portals</div>
                    <div class="modifier-item" data-modifier="ice">Ice Physics</div>
                    <div class="modifier-item" data-modifier="bomb">Food Bombs</div>
                    <div class="modifier-item" data-modifier="walls">Moving Walls</div>
                    <div class="modifier-item" data-modifier="wind">Strong Winds</div>
                    <div class="modifier-item" data-modifier="dark">Limited Vision</div>
                    <div class="modifier-item" data-modifier="gold">Golden Apples</div>
                    <div class="modifier-item" data-modifier="mirror">Mirror World</div>
                </div>
            </div>

            <div class="active-modifiers" id="activeModifiers">
                <!-- Active modifier tags will be added here -->
            </div>

            <button id="startButton">Start Game</button>
            <button id="pauseButton">Pause</button>

            <div class="info-panel">
                <p>Controls: Arrow Keys or WASD</p>
                <p>Space: Pause/Resume</p>
                <p>Current Mode: <span id="currentMode">Classic</span></p>
            </div>
        </div>
    </div>

    <script>
class SnakeGame {
    constructor() {
        this.canvas = document.getElementById('gameCanvas');
        this.ctx = this.canvas.getContext('2d');
        this.cellSize = 20;
        this.gridSize = this.canvas.width / this.cellSize;
        
        // Game state
        this.snake = [];
        this.food = {};
        this.direction = {};
        this.nextDirection = {};
        this.score = 0;
        this.gameLoop = null;
        this.gameSpeed = 150;
        
        // Game settings
        this.currentMode = 'classic';
        this.activeModifiers = new Set();
        this.paused = false;
        this.gameOver = false;
        
        // Special elements
        this.portals = [];
        this.walls = [];
        this.powerups = [];
        
        // Mode-specific variables
        this.timeLeft = 0;
        this.darknessRadius = 100;
        this.windForce = 0;
        
        this.setupEventListeners();
        this.setupGameModes();
    }

    setupEventListeners() {
        // Mode selection
        document.querySelectorAll('.mode-item').forEach(mode => {
            mode.addEventListener('click', () => {
                document.querySelectorAll('.mode-item').forEach(m => m.classList.remove('selected'));
                mode.classList.add('selected');
                this.currentMode = mode.dataset.mode;
                document.getElementById('currentMode').textContent = mode.textContent;
            });
        });

        // Modifier selection
        document.querySelectorAll('.modifier-item').forEach(modifier => {
            modifier.addEventListener('click', () => {
                if (modifier.classList.contains('selected')) {
                    modifier.classList.remove('selected');
                    this.activeModifiers.delete(modifier.dataset.modifier);
                } else if (this.activeModifiers.size < 3) {
                    modifier.classList.add('selected');
                    this.activeModifiers.add(modifier.dataset.modifier);
                }
                this.updateModifierTags();
            });
        });

        // Controls
        document.addEventListener('keydown', (e) => this.handleKeyPress(e));
        document.getElementById('startButton').addEventListener('click', () => this.startGame());
        document.getElementById('pauseButton').addEventListener('click', () => this.togglePause());
    }

    handleKeyPress(e) {
        if (this.gameOver) return;

        const key = e.key.toLowerCase();
        const reverseControls = this.activeModifiers.has('reverse');
        
        const directionMap = {
            'arrowleft': { x: reverseControls ? 1 : -1, y: 0 },
            'arrowright': { x: reverseControls ? -1 : 1, y: 0 },
            'arrowup': { x: 0, y: reverseControls ? 1 : -1 },
            'arrowdown': { x: 0, y: reverseControls ? -1 : 1 },
            'a': { x: reverseControls ? 1 : -1, y: 0 },
            'd': { x: reverseControls ? -1 : 1, y: 0 },
            'w': { x: 0, y: reverseControls ? 1 : -1 },
            's': { x: 0, y: reverseControls ? -1 : 1 },
            ' ': 'pause'
        };

        const newDirection = directionMap[key];
        
        if (newDirection === 'pause') {
            this.togglePause();
        } else if (newDirection && !this.paused) {
            // Prevent 180-degree turns
            if (this.direction.x !== -newDirection.x || this.direction.y !== -newDirection.y) {
                this.nextDirection = newDirection;
            }
        }
    }

    startGame() {
        this.reset();
        this.gameLoop = setInterval(() => this.update(), this.gameSpeed);
        document.getElementById('startButton').textContent = 'Restart';
    }

    reset() {
        // Clear previous game state
        clearInterval(this.gameLoop);
        
        // Reset basic game state
        this.snake = [{x: 5, y: 5}];
        this.direction = {x: 1, y: 0};
        this.nextDirection = {x: 1, y: 0};
        this.score = 0;
        this.gameOver = false;
        this.paused = false;
        
        // Reset mode-specific elements
        this.walls = [];
        this.portals = [];
        this.powerups = [];
        
        // Initialize mode-specific settings
        this.initializeGameMode();
        
        // Update UI
        document.getElementById('scoreValue').textContent = '0';
        document.getElementById('status').style.display = 'none';
        
        // Generate initial food
        this.generateFood();
    }

    initializeGameMode() {
        switch(this.currentMode) {
            case 'maze':
                this.generateMaze();
                break;
            case 'portal':
                this.generatePortals();
                break;
            case 'timeAttack':
                this.timeLeft = 60;
                this.startTimer();
                break;
            // Add more mode initializations here
        }

        // Apply modifier effects
        this.applyModifiers();
    }

    applyModifiers() {
        this.activeModifiers.forEach(modifier => {
            switch(modifier) {
                case 'speed':
                    this.gameSpeed *= 0.7;
                    break;
                case 'giant':
                    this.cellSize *= 1.5;
                    break;
                case 'tiny':
                    this.cellSize *= 0.7;
                    break;
                // Add more modifier effects
            }
        });
    }

    update() {
        if (this.paused || this.gameOver) return;

        // Update snake position
        const newHead = {
            x: this.snake[0].x + this.nextDirection.x,
            y: this.snake[0].y + this.nextDirection.y
        };

        // Apply mode-specific effects
        this.applyModeEffects(newHead);

        // Check collisions
        if (this.checkCollision(newHead)) {
            this.handleGameOver();
            return;
        }

        // Move snake
        this.snake.unshift(newHead);
        
        // Check food collision
        if (this.checkFoodCollision(newHead)) {
            this.handleFoodCollection();
        } else {
            this.snake.pop();
        }

        // Update direction for next frame
        this.direction = {...this.nextDirection};

        // Draw game state
        this.draw();
    }

    applyModeEffects(head) {
        switch(this.currentMode) {
            case 'infinity':
                // Wrap around edges
                head.x = (head.x + this.gridSize) % this.gridSize;
                head.y = (head.y + this.gridSize) % this.gridSize;
                break;
            case 'wind':
                // Apply wind force
                head.x += Math.sin(Date.now() / 1000) * 0.1;
                break;
            case 'shrinking':
                // Gradually reduce playable area
                this.updateShrinkingBoundary();
                break;
            case 'chaos':
                // Randomly move food
                if (Math.random() < 0.02) this.generateFood();
                break;
        }

        // Apply modifier effects
        if (this.activeModifiers.has('wind')) {
            head.x += Math.sin(Date.now() / 500) * 0.2;
        }
    }

    generateMaze() {
        this.walls = [];
        const wallCount = Math.floor(this.gridSize * this.gridSize * 0.1);
        
        for (let i = 0; i < wallCount; i++) {
            const wall = {
                x: Math.floor(Math.random() * this.gridSize),
                y: Math.floor(Math.random() * this.gridSize)
            };
            
            // Don't place walls near starting position
            if (Math.abs(wall.x - 5) > 2 || Math.abs(wall.y - 5) > 2) {
                this.walls.push(wall);
            }
        }
    }

    generatePortals() {
        this.portals = [];
        for (let i = 0; i < 2; i++) {
            const portal = {
                x: Math.floor(Math.random() * this.gridSize),
                y: Math.floor(Math.random() * this.gridSize),
                color: i === 0 ? '#00ffff' : '#ff00ff'
            };
            this.portals.push(portal);
        }
    }

    generateFood() {
        do {
            this.food = {
                x: Math.floor(Math.random() * this.gridSize),
                y: Math.floor(Math.random() * this.gridSize),
                type: this.activeModifiers.has('gold') && Math.random() < 0.2 ? 'gold' : 'normal'
            };
        } while (
            this.snake.some(segment => segment.x === this.food.x && segment.y === this.food.y) ||
            this.walls.some(wall => wall.x === this.food.x && wall.y === this.food.y)
        );
    }

    checkCollision(head) {
        // Wall collision
        if (!this.currentMode === 'infinity') {
            if (head.x < 0 || head.x >= this.gridSize || head.y < 0 || head.y >= this.gridSize) {
                return true;
            }
        }

        // Self collision (unless ghost modifier is active)
        if (!this.activeModifiers.has('ghost')) {
            if (this.snake.some(segment => segment.x === head.x && segment.y === head.y)) {
                return true;
            }
        }

        // Maze wall collision
        return this.walls.some(wall => wall.x === head.x && wall.y === head.y);
    }

    checkFoodCollision(head) {
        return head.x === this.food.x && head.y === this.food.y;
    }

    handleFoodCollection() {
        // Update score
        const basePoints = this.food.type === 'gold' ? 50 : 10;
        const multiplier = this.activeModifiers.has('multiplier') ? 2 : 1;
        this.score += basePoints * multiplier;
        document.getElementById('scoreValue').textContent = this.score;

        // Generate new food
        this.generateFood();

        // Mode-specific food effects
        if (this.currentMode === 'growing') {
            this.addWall();
        }
    }

    addWall() {
        const wall = {
            x: Math.floor(Math.random() * this.gridSize),
            y: Math.floor(Math.random() * this.gridSize)
        };
        this.walls.push(wall);
    }

    draw() {
        // Clear canvas
        this.ctx.fillStyle = '#1a1a2e';
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

        // Draw grid
        if (this.currentMode !== 'dark' || !this.activeModifiers.has('dark')) {
            this.drawGrid();
        }

        // Draw walls
        this.walls.forEach(wall => {
            this.ctx.fillStyle = '#666666';
            this.ctx.fillRect(
                wall.x * this.cellSize,
                wall.y * this.cellSize,
                this.cellSize - 1,
                this.cellSize - 1
            );
        });

        // Draw portals
        this.portals.forEach(portal => {
            this.drawPortal(portal);
        });

        // Draw snake
        this.snake.forEach((segment, index) => {
            this.drawSnakeSegment(segment, index);
        });

        // Draw food
        this.drawFood();

        // Draw darkness overlay for dark mode
        if (this.currentMode === 'dark' || this.activeModifiers.has('dark')) {
            this.drawDarknessOverlay();
        }
    }

    drawGrid() {
        this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
        this.ctx.beginPath();
        for (let i = 0; i <= this.canvas.width; i += this.cellSize) {
            this.ctx.moveTo(i, 0);
            this.ctx.lineTo(i, this.canvas.height);
            this.ctx.moveTo(0, i);
            this.ctx.lineTo(this.canvas.width, i);
        }
        this.ctx.stroke();
    }

    drawSnakeSegment(segment, index) {
        let color = this.activeModifiers.has('rainbow') 
            ? `hsl(${(Date.now() / 20 + index * 10) % 360}, 100%, 50%)`
            : '#4ecca3';

        if (this.activeModifiers.has('ghost')) {
            this.ctx.globalAlpha = 0.5;
        }

        this.ctx.fillStyle = color;
        this.ctx.beginPath();
        this.ctx.roundRect(
            segment.x * this.cellSize,
            segment.y * this.cellSize,
            this.cellSize - 1,
            this.cellSize - 1,
            index === 0 ? this.cellSize / 3 : this.cellSize / 5
        );
        this.ctx.fill();

        this.ctx.globalAlpha = 1;
    }

    drawFood() {
        const color = this.food.type === 'gold' ? '#ffd700' : '#ff6b6b';
        const pulseSize = 1 + Math.sin(Date.now() / 200) * 0.1;

        this.ctx.fillStyle = color;
        this.ctx.beginPath();
        this.ctx.arc(
            (this.food.x + 0.5) * this.cellSize,
            (this.food.y + 0.5) * this.cellSize,
            (this.cellSize / 2 - 1) * pulseSize,
            0,
            Math.PI * 2
        );
        this.ctx.fill();
    }

    drawPortal(portal) {
        const gradient = this.ctx.createRadialGradient(
            (portal.x + 0.5) * this.cellSize,
            (portal.y + 0.5) * this.cellSize,
            0,
            (portal.x + 0.5) * this.cellSize,
            (portal.y + 0.5) * this.cellSize,
            this.cellSize
        );
        gradient.addColorStop(0, portal.color);
        gradient.addColorStop(1, 'transparent');

        this.ctx.fillStyle = gradient;
        this.ctx.beginPath();
        this.ctx.arc(
            (portal.x + 0.5) * this.cellSize,
            (portal.y + 0.5) * this.cellSize,
            this.cellSize,
            0,
            Math.PI * 2
        );
        this.ctx.fill();
    }

    drawDarknessOverlay() {
        const gradient = this.ctx.createRadialGradient(
            this.snake[0].x * this.cellSize,
            this.snake[0].y * this.cellSize,
            0,
            this.snake[0].x * this.cellSize,
            this.snake[0].y * this.cellSize,
            this.darknessRadius
        );
        gradient.addColorStop(0, 'transparent');
        gradient.addColorStop(1, 'rgba(0, 0, 0, 0.95)');

        this.ctx.fillStyle = gradient;
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
    }

    handleGameOver() {
        this.gameOver = true;
        clearInterval(this.gameLoop);
        
        const status = document.getElementById('status');
        status.textContent = `Game Over! Score: ${this.score}`;
        status.style.display = 'block';
        
        // Save high score for current mode
        this.saveHighScore();
    }

    saveHighScore() {
        const highScores = JSON.parse(localStorage.getItem('snakeHighScores') || '{}');
        if (!highScores[this.currentMode]) {
            highScores[this.currentMode] = [];
        }
        highScores[this.currentMode].push(this.score);
        highScores[this.currentMode].sort((a, b) => b - a);
        highScores[this.currentMode] = highScores[this.currentMode].slice(0, 5);
        localStorage.setItem('snakeHighScores', JSON.stringify(highScores));
    }

    togglePause() {
        if (this.gameOver) return;
        
        this.paused = !this.paused;
        document.getElementById('pauseButton').textContent = this.paused ? 'Resume' : 'Pause';
        
        if (!this.paused) {
            this.showCountdown();
        }
    }

    showCountdown() {
        const status = document.getElementById('status');
        let count = 3;
        
        const countDown = () => {
            if (count > 0) {
                status.textContent = count;
                status.style.display = 'block';
                count--;
                setTimeout(countDown, 1000);
            } else {
                status.style.display = 'none';
                this.gameLoop = setInterval(() => this.update(), this.gameSpeed);
            }
        };
        
        countDown();
    }

    updateModifierTags() {
        const container = document.getElementById('activeModifiers');
        container.innerHTML = '';
        this.activeModifiers.forEach(modifier => {
            const tag = document.createElement('span');
            tag.className = 'modifier-tag';
            tag.textContent = modifier;
            container.appendChild(tag);
        });
    }
}

// Initialize the game
const game = new SnakeGame();
</script>
</body>
</html>
